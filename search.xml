<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>webpack中的loader</title>
    <url>/2020/09/23/webpack%E4%B8%AD%E7%9A%84loader/</url>
    <content><![CDATA[<ol>
<li><a href="#loader%E7%9A%84%E4%BD%9C%E7%94%A8">loader的作用</a></li>
<li><a href="#loader%E7%9A%84%E4%BD%BF%E7%94%A8">loader的使用</a></li>
<li><a href="#loader">loader</a><ol>
<li><a href="#css-loader-%E5%92%8C-style-loader">css-loader 和 style-loader</a></li>
<li><a href="#less-loader">less-loader</a></li>
<li><a href="#url-loader">url-loader</a><ol>
<li><a href="#%E4%BD%9C%E7%94%A8">作用</a></li>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
</ol>
</li>
<li><a href="#file-loader">file-loader</a><ol>
<li><a href="#%E5%85%B3%E4%BA%8E%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D">关于生成的文件名</a></li>
</ol>
</li>
<li><a href="#babel-loader">babel-loader</a></li>
</ol>
</li>
<li><a href="#%E6%AD%A4%E7%AB%A0%E5%AE%8C%E7%BB%93">此章完结</a></li>
</ol>
<h1 id="loader的作用"><a href="#loader的作用" class="headerlink" title="loader的作用"></a>loader的作用</h1><ol>
<li><p>在之前的案例中，主要是使用webpack来处理所写的JS代码，并通过webpack来自动处理他们之间的依赖。</p>
</li>
<li><p>但是在实际开发中并不只JS文件的处理，还会加载css文件、图片等，对于webpack本身来说，对于这些转化是不支持的。</p>
</li>
<li><p>所以就需要给webpack扩展对应的loader。</p>
<a id="more"></a>

</li>
</ol>
<h1 id="loader的使用"><a href="#loader的使用" class="headerlink" title="loader的使用"></a>loader的使用</h1><ol>
<li>通过npm安装所需要的loader。(<a href="https://www.webpackjs.com/">webpack中文官网</a>)</li>
<li>webpack.config.js中的modules属性下配置。</li>
</ol>
<h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><h2 id="css-loader-和-style-loader"><a href="#css-loader-和-style-loader" class="headerlink" title="css-loader 和 style-loader"></a>css-loader 和 style-loader</h2><p>当没有使用css-loader时，直接在main.js文件中引用依赖然后打包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//normal.css</span></span><br><span class="line">body &#123;</span><br><span class="line">	background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;name,age,say,run&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./js/info.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(say);</span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="comment">//依赖CSS文件，使得webpack打包时会处理normal.css文件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./css/normal.css&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>控制台会输出如下错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/serystal/heyuhangspic/20200922165432.png" alt="合适的loader处理"></p>
<p>所以需要安装css-loader来处理css文件。使用<code>npm install --save-dev css-loader</code>。<br>💥<font color="red"><code>--save-dev</code> 为开发时依赖模块，意为只用于开发，实际项目运行时并不依赖。</font> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line"> &#123;</span><br><span class="line">   test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">   use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注： 如果只是安装css-loader并打包，在DOM中并不会显示出css文件定义的效果。因为css-loader只是<strong>将css文件加载</strong>，想要将加载好的css文件渲染到DOM中，还需要安装<strong>style-loader</strong>(<code>npm install style-loader --save-dev</code>)；</p>
<p>在使用<code> use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]</code>这个语句时，应注意在使用多个loader时，loader的执行顺序是从右往左，所以应该将style-loader放在左边，先执行css-loader加载css文件之后，再由style-loader渲染到DOM中。</p>
</blockquote>
<h2 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h2><blockquote>
<p>Less 是一门 <strong>CSS 预处理语言</strong>，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。</p>
</blockquote>
<p><strong>less-loader</strong>用于处理JS文件中对less文件的依赖。</p>
<ol>
<li><p>安装less-loader：使用指令<code>npm install --save-dev less-loader less</code>。</p>
<p>*⚠️注： 如需安装指定版本，需要在loader后加 <code>@+版本号</code>*。以下同理。</p>
</li>
<li><p>在webpack.config.js文件中配置(执行顺序是<strong>自下而上</strong>)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> test: <span class="regexp">/\.less$/</span>,</span><br><span class="line"> use: [&#123;</span><br><span class="line">  loader: <span class="string">&quot;style-loader&quot;</span></span><br><span class="line"> &#125;, &#123;</span><br><span class="line">     loader: <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      	loader: <span class="string">&quot;less-loader&quot;</span>, <span class="attr">options</span>: &#123;</span><br><span class="line">      	strictMath: <span class="literal">true</span>,</span><br><span class="line">      	noIeCompat: <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line"> &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>使用<code>url-loader</code>加载css样式中的一些图片等文件。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用指令：<code>npm install --save-dev url-loader</code>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在<strong>webpack.config.js</strong>中配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line"> use: [&#123;</span><br><span class="line">  loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">   <span class="comment">//当文件小于limit所定义的数值时，会将图片编译成base64字符串形式。</span></span><br><span class="line">   <span class="comment">//当图片大于limit定义的数值时，打包会报错，就需要使用file-loader模块进行加载。</span></span><br><span class="line">   limit: <span class="number">13000</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 🔊如果插入的图片过大，就需要使用 file-loader模块进行加载。</p>
<h2 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h2><blockquote>
<p>用于处理<strong>大文件</strong>的加载.</p>
</blockquote>
<ol>
<li><p>安装指令: <code>npm install --save-dev file-loader</code>。</p>
</li>
<li><p>然后再次运行打包指令。</p>
</li>
<li><p>运行index.html，控制台会提示找不到文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200923202519.png"></p>
</li>
<li><p>是由于使用webpack打包时，webpack会把图片文件放到打包文件同一路径下直接引用，但是是直接引用，未指定前置路径。</p>
<p>​                                            <img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/123.jpg"></p>
<center><font size="2">同一路径</font></center>                                

<p><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200923203232.png"></p>
<center><font size="2">没有前置路径</font></center>    
</li>
<li><p>在调试中将url路径改为<br><code>url(dist/8e08b79ef4c5e855db743e16c3b5f2a1.png)</code>，<br>此时页面就会正常渲染。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200923203926.png"></p>
</li>
<li><p>如果想要解决这个问题，就需要使background后的url引用路径改为<code>dist/xxx.jpg</code>。在webpack.config.js文件中加入<code>publicPath: &#39;dist/&#39;</code>。意为只要涉及到url的问题，都会自动地在文件前面加上==dist/==。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200923204400.png"></p>
<center><font size="2">问题解决</font></center>

<table><tr><td bgcolor=PowderBlue>💡当index.html文件也在<b>dist</b>文件夹下，<br />则不需要再使用 <i>publicPath: 'dist/'</i>指令</td></tr></table>

<h3 id="关于生成的文件名"><a href="#关于生成的文件名" class="headerlink" title="关于生成的文件名"></a>关于生成的文件名</h3><ul>
<li><p>webpack会在打包时将文件放入打包文件的同一目录下，并且会生成一个32位的hash值，防止文件命名重复。</p>
</li>
<li><p>但是在实际的开发中，我们可能对打包的名字有一定的要求——比如，将所有的图片放在一个文件夹中，但是需要跟上原来的名字，同时还要防止重复。</p>
</li>
<li><p>此时我们需要在options中添加一个<strong>name</strong>属性：</p>
<ul>
<li><code>img</code>：文件要打包的文件夹；</li>
<li><code>name</code>：获取图片原来的名字，放在该位置；</li>
<li><code>hash:8</code>：为了防止图片名称重复，依然使用hash，但是只保留8位；</li>
<li><code>ext</code>：原来的图片扩展名。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用[name]就是使用图片原有的name，使用.是将名称连接起来</span></span><br><span class="line">name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将原本打包好的的文件删除，然后重新打包<code>npm run build</code>。</p>
<p>​                                                    <img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/Snipaste20200923222351.jpg"></p>
</li>
</ul>
<center><font size="2">完成打包在img目录下的自定义图片名称</font></center>



<h2 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h2><p><font color="green">🏆我们上述的打包文件中会有ES6的语法，当浏览器不支持ES6时会无法正常渲染，所以我们需要使用babel-loader模块完成转换。</font></p>
<ul>
<li><p>安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install babel-loader babel-core babel-preset-env webpack</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">	<span class="comment">//由于最后打包完成并运行node依赖文件并不参加，所以使用exclude将文件排除</span></span><br><span class="line"> exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line"> use: &#123;</span><br><span class="line"> 	loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line"> 	options: &#123;</span><br><span class="line">	 <span class="comment">// presets: [&#x27;@babel/preset-env&#x27;]</span></span><br><span class="line">	<span class="comment">// 为什么使用2015版本不知</span></span><br><span class="line">	presets: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>再次运行<code>npm run build</code>。打包完成，然后进入打包好的文件<strong>bundle.js</strong>搜索ES6的语法(如<code>let</code>,<code>const</code>)，没有搜到，说明已经成功将ES6的语法转化为ES5。<br><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200924181951.png" alt="没有const"><br><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200924182035.png" alt="没有let"></li>
</ul>
</li>
</ul>
<h1 id="此章完结"><a href="#此章完结" class="headerlink" title="此章完结"></a>此章完结</h1>]]></content>
      <categories>
        <category>Web前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack配置Vue</title>
    <url>/2020/09/24/webpack%E9%85%8D%E7%BD%AEVue/</url>
    <content><![CDATA[<h1 id="Vue模块"><a href="#Vue模块" class="headerlink" title="Vue模块"></a>Vue模块</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在之前的学习过程中，在项目中引用Vue大致是使用两种方法：</p>
<ol>
<li><p>下载Vue.js文件，然后通过<code>&lt;script&gt;</code>标签引入；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用cdn引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>💥而这两种方法都是不符合我们的<strong>模块化</strong>开发思想的，模块化开发应该是以引入模块的方式进行使用。所以我们需要使用npm安装的方式来引入vue模块。</p>
<p>使用指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>

<p><font color="green">注：由于Vue在运行时也是需要依赖的，所以不需要使用<code>--save-dev。</code></font></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>在js文件中使用vue进行开发：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用vue进行开发</span></span><br><span class="line"><span class="comment">//导入vue模块，引号中的vue就是安装好的vue模块</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&#x27;hello webpack&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在index.html文件中输入代码并执行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="运行时的错误-模板编译器"><a href="#运行时的错误-模板编译器" class="headerlink" title="运行时的错误-模板编译器"></a>运行时的错误-模板编译器</h2><ol>
<li><p>并没有执行，浏览器会抛出一个错误：<br><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/image-20200924224202310.png" alt="正在使用vue的runtime-only版本，模板编译器不可用。"></p>
<p>🗨️这是由于vue模块有两个版本：<code>runtime-only</code> 和 <code>runtime-compiler</code>：</p>
<ul>
<li>runtime-only =&gt; 代码中不可以有任何的<strong>template</strong>；</li>
<li>runtime-compiler  =&gt; 代码可以有<strong>template</strong>，因为有<code>compiler</code>用于编译template。</li>
</ul>
<p>🗨️因为使用的是前者打包，它其中并没有包含模板编译器，所以浏览器无法正常运行。<font size=2 color=red>被Vue实例el属性挂载的元素也可以看做是一个模板</font></p>
</li>
<li><p>解决这个问题需要在webpack.config.js文件中加入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  <span class="comment">//别名</span></span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="comment">// vue$表示以vue结尾的文件,由于默认情况下vue使用的是vue.runtime.js，所以我们需要将vue的默认使用改变从而使用runtime-compiler。</span></span><br><span class="line">    <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center><font size=2>是将Vue的默认使用文件改变为<b>vue.esm.js</b>从而可以使用模板编译器</font></center>
</li>
<li><p>再次<code>npm run build</code>，就可以在浏览器中正常渲染啦！<br><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/1154545454545454.jpg" alt="hello webpack"></p>
</li>
</ol>
<h1 id="创建Vue时el和template的关系"><a href="#创建Vue时el和template的关系" class="headerlink" title="创建Vue时el和template的关系"></a>创建Vue时el和template的关系</h1><blockquote>
<p>在上面的代码可以正常运行后，有一个问题出现了：</p>
<p>❓ 当我们后续想要添加或修改data或其他属性的引用方式，我们就需要在index.html中修改相应的代码。那么有没有一种方法可以使我们在js文件中就可以修改呢？</p>
</blockquote>
<h2 id="Vue实例中的template属性"><a href="#Vue实例中的template属性" class="headerlink" title="Vue实例中的template属性"></a>Vue实例中的template属性</h2><p>答案是我们可以在Vue实例中定义一个<strong>template</strong>属性：</p>
<ul>
<li><p>在之前，我们只是定义了el属性，使得Vue实例对html中一个元素进行绑定；</p>
</li>
<li><p>现在我们只在html中保留一个div#app的元素，然后在Vue实例中定义一个<code>template</code>属性；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;btnClick&quot;&gt;点击事件&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&#x27;hello webpack&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;coderbut&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    btnClick()&#123;</span><br><span class="line">      alert(<span class="string">&#x27;alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成之后即使html页面只有一个div#app元素，也可以正常渲染。有利于文件的分离。<br><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/image-20200925003902466.png" alt="正常渲染"></p>
</li>
</ul>
<h2 id="分离写法"><a href="#分离写法" class="headerlink" title="分离写法"></a>分离写法</h2><p>在上面，使用了Vue实例中的template属性，从而使前端html文件中只有一个div#app的元素。</p>
<p>我们可以定义一个子组件，将属性从Vue实例中分离出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;btnClick&quot;&gt;点击事件&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&#x27;hello webpack&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;coderbut&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    btnClick() &#123;</span><br><span class="line">      alert(<span class="string">&#x27;alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在Vue实例中注册模板，并在实例中的<code> template</code>属性中使用组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App /&gt;&#x27;</span>,</span><br><span class="line">  components:&#123;</span><br><span class="line">    App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打包并运行，这样也可以得到相同的效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200925142500.png" alt="template: ‘&lt;App /&gt;’"></p>
<h2 id="模块化-在js文件中导出"><a href="#模块化-在js文件中导出" class="headerlink" title="模块化 - 在js文件中导出"></a>模块化 - 在js文件中导出</h2><p>✨除了上述在一个js文件中定义一个子组件，还可以在另一个js文件中定义并导出，然后在mian.js文件中导入。</p>
<ol>
<li><p>定义一个App.js文件，并编辑。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//App.js</span></span><br><span class="line"><span class="comment">//default表示导出一个模块并且由导入者命名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;btnClick&quot;&gt;点击事件&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&#x27;hello webpack&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;coderbut&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    btnClick() &#123;</span><br><span class="line">      alert(<span class="string">&#x27;alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./js/App&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App /&gt;&#x27;</span>,</span><br><span class="line">  components:&#123;</span><br><span class="line">    App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包并运行，依然可以得到相同的效果。</p>
</li>
</ol>
<h2 id="模块化-在-vue文件中配置"><a href="#模块化-在-vue文件中配置" class="headerlink" title="模块化 - 在.vue文件中配置"></a>模块化 - 在<code>.vue</code>文件中配置</h2><p>在使用vue模块中，我们可以定义后缀为<code>.vue</code>的文件，在里面定义属性模板，之后在js文件中引用。</p>
<ol>
<li><p>首先创建一个App.vue文件。<br><img src="https://cdn.jsdelivr.net/gh/serystal/heyuhangspic/img/Snipaste20200925154258521.jpg" alt="vue文件模板"></p>
</li>
<li><p>在vue文件中编辑。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      msg: <span class="string">&#x27;hello webpack&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;coderbut&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    btnClick() &#123;</span><br><span class="line"><span class="javascript">      alert(<span class="string">&#x27;alert&#x27;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--可以为模板内的元素定义样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">h2 &#123;</span><br><span class="line">  color: powderblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>此时如果直接打包会报错。<br><img src="https://cdn.jsdelivr.net/gh/serystal/heyuhangspic/img/Snipaste20200925161252619.png" alt="需要使用vue-loader"></p>
</li>
<li><p>我们需要安装<strong>vue-loader</strong>和<strong>vue-template-compiler</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure>

<p>然后在webpack.config.js文件中添加规则:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//意为 .vue 文件使用vue-loader处理</span></span><br><span class="line">    test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">    use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>🚨注：在vue-loader<strong>14版本</strong>之后，使用vue-loader需要另外配置一个插件，这次我们把vue-loader的版本改到13 。</p>
</li>
<li><p>更改vue-loader版本。</p>
<p>进入package.json文件，将vue-loader的版本改为<code>^13.0.0</code> 。再次运行<code>npm install</code>。</p>
</li>
<li><p>安装完成之后再次运行<code>npm run build</code>进行打包。</p>
</li>
<li><p>运行。<br><img src="https://cdn.jsdelivr.net/gh/serystal/heyuhangspic/img/Snipaste20200925163357818.png" alt="可以正常运行，并且定义 样式也生效了"></p>
</li>
</ol>
<p>当然，在vue文件中也可以导入vue文件(套娃警告)。</p>
<ol>
<li><p>定义另一个vue文件<code>Cpn.vue</code>；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cpn.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;Cpn&quot;</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&#x27;cpn template&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在App.vue中导入并注册；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">    Cpn</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后重新打包并运行，就可以看到我们在App.vue中使用的Cpn.vue的内容了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200925213653022.png" alt="执行效果"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的plugin(插件)</title>
    <url>/2020/09/26/webpack%E7%9A%84plugin(%E6%8F%92%E4%BB%B6)/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="什么是plugin？"><a href="#什么是plugin？" class="headerlink" title="什么是plugin？"></a>什么是plugin？</h1><p>🦆    plugin是插件的意思，通常是用于对某个现有的架构进行扩展；</p>
<p>🦆    webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</p>
<h1 id="plugin和loader的区别"><a href="#plugin和loader的区别" class="headerlink" title="plugin和loader的区别"></a>plugin和loader的区别</h1><p>👁️    loader主要用于转换某些类型的模块，它是一个<strong>转换器</strong>；</p>
<p>👁️    plugin是插件，它是对webpack本身的扩展，是一个<strong>扩展器</strong>。</p>
<h1 id="plugin的使用"><a href="#plugin的使用" class="headerlink" title="plugin的使用"></a>plugin的使用</h1><ol>
<li>通过npm安装需要使用plugins(某些webpack内置的插件无需安装)；</li>
<li>在webpack.config.js文件中<code>plugins</code>中配置插件。</li>
</ol>
<h1 id="webpack的各种plugins"><a href="#webpack的各种plugins" class="headerlink" title="webpack的各种plugins"></a>webpack的各种plugins</h1><h2 id="BannerPlugin插件"><a href="#BannerPlugin插件" class="headerlink" title="BannerPlugin插件"></a>BannerPlugin插件</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>BannerPlugin是webpack的<strong>自带插件</strong>，用来为打包的文件添加版本声明。</p>
<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><ol>
<li><p>修改webpack.config.js文件(由于是自带插件，所以不需要安装)：</p>
<ul>
<li><p>首先导入webpack模块</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入webpack</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在属性中添加<code>plugins</code>属性并定义</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">	<span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;最终版权归coderbut所有&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>重新打包，然后在打包好的bundle.js文件中就可以看到我们用BannerPlugin定义的内容了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200926004815291.png" alt="BannerPlugin"></p>
</li>
</ol>
<h2 id="HtmlWebpackPlugin插件"><a href="#HtmlWebpackPlugin插件" class="headerlink" title="HtmlWebpackPlugin插件"></a>HtmlWebpackPlugin插件</h2><p>目前我们的index.html是存放于<strong>根目录</strong>下的，在发布项目时，只是会发布<code>dist</code>文件夹，但是如果该文件夹下没有index.html文件，那么打包好的js文件也就无法使用了，所以我们需要将index.html文件也打包到dist文件夹中，这时就需要使用<code>HtmlWerbpackPlugin</code>插件了。</p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>▶️&emsp;自动生成一个index.html文件(可以指定模板生成)；</p>
<p>▶️&emsp;将打包好的js文件，通过<code>&lt;script&gt;</code>标签插入到<code>&lt;body&gt;</code>中。</p>
<h3 id="具体使用-1"><a href="#具体使用-1" class="headerlink" title="具体使用"></a>具体使用</h3><ol>
<li><p>安装插件(学习的时候安装3.2.0版本，高版本会报错)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin@3.2.0 --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改webpack.config.js中的<code>plugins</code>内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">	<span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包，之后就可以在dist目录下看到index.html文件，并且自动引入了bundle.js文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200926013829932.png" alt="dist文件下的index.html"></p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200926013926906.png" alt="自动引入了bundle.js"></p>
<p>注： 由于现在index和bundle文件打包在同一目录下,所以我们不再需要使用webpack.config.js文件中的<code>publicPath</code>属性来指定路径。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste202009260151467761223.png" alt="注释掉publicPate"></p>
</li>
</ol>
<h2 id="UglifyjsWebpackPlugin插件"><a href="#UglifyjsWebpackPlugin插件" class="headerlink" title="UglifyjsWebpackPlugin插件"></a>UglifyjsWebpackPlugin插件</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>压缩打包好的js文件。使js文件变得可读性差。</p>
<h3 id="具体使用-2"><a href="#具体使用-2" class="headerlink" title="具体使用"></a>具体使用</h3><ol>
<li><p>安装插件(安装1.1.0版本，高版本报错)；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin@1.1.0 --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>在webpack.config.js中配置；</p>
<ul>
<li><p>引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入UglifyWebpackPlugin插件</span></span><br><span class="line"><span class="keyword">const</span> UglifyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置plugins</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> UglifyWebpackPlugin()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>再次打包，找到bundle.js文件查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200926150047481.png" alt="压缩混淆之后"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
