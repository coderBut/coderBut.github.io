<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用yarn下载全局包的一些坑</title>
    <url>/2020/09/27/%E4%BD%BF%E7%94%A8yarn%E4%B8%8B%E8%BD%BD%E5%85%A8%E5%B1%80%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
    <content><![CDATA[<h1 id="yarn安装全局包不能全局使用的问题"><a href="#yarn安装全局包不能全局使用的问题" class="headerlink" title="yarn安装全局包不能全局使用的问题"></a>yarn安装全局包不能全局使用的问题</h1><p>使用yarn全局安装了**@vue/cli**</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add @vue&#x2F;cli</span><br></pre></td></tr></table></figure>

<p>但是在终端中使用<code>vue --version</code>提示</p>
<blockquote>
<p>‘vue’ 不是内部或外部命令，也不是可运行的程序<br>或批处理文件。</p>
</blockquote>
<p>但是明明已经使用global add全局安装了呀！在网上找到了解决方法：</p>
<ol>
<li><p>在终端运行<code>yarn global bin</code>得到一个路径，是yarn全局bin文件的路径</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/yarnbingggg.jpg" alt="yarnbingggg"></p>
</li>
<li><p>之后去到环境变量中，在Path变量中添加上面得到的路径；</p>
</li>
<li><p>重启终端，然后再次执行<code>vue --version</code>，就可以正常显示了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中级的笔记</title>
    <url>/2020/09/27/vue%E4%B8%AD%E7%BA%A7%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Vue-Cli-脚手架"><a href="#Vue-Cli-脚手架" class="headerlink" title="Vue Cli(脚手架)"></a>Vue Cli(脚手架)</h1><blockquote>
<p><a href="https://cli.vuejs.org/zh/guide/">Vue Cli文档</a></p>
<p>如果只是写vue的demo程序可能使用不到Vue Cli，但是开发大型项目，就必然要使用Vue Cli。</p>
<p>使用Vuejs开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情。如果每个项目都要手动完成这些工作，那无疑效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情。</p>
</blockquote>
<h2 id="什么是Cli"><a href="#什么是Cli" class="headerlink" title="什么是Cli"></a>什么是Cli</h2><ul>
<li>Cu是Command—Line Interface，翻译为命令行界面，但是俗称脚手架；</li>
<li>Vue CL是一个官方发布vue.js项目脚手架；</li>
<li>使用vue—cli可以快速搭建Vue开发环境以及对应的webpack配置.</li>
</ul>
<h2 id="Vue-Cli的前提"><a href="#Vue-Cli的前提" class="headerlink" title="Vue Cli的前提"></a>Vue Cli的前提</h2><ul>
<li><p><strong>node</strong></p>
<ul>
<li><p>需要安装node和npm，使用npm安装模块或者插件速度慢的话也可以使用cnpm阿里镜像下载，速度可能会快点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install cnpm -g --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>webpack</p>
</li>
</ul>
<h2 id="使用Vue-Cli"><a href="#使用Vue-Cli" class="headerlink" title="使用Vue Cli"></a>使用Vue Cli</h2><p>由于npm实在太慢了，改用yarn安装。全局yarn安装方式：在终端执行<code>npm install -g yarn</code>。</p>
<p>关于yarn还有一些坑：<a href="/2020/09/27/%E4%BD%BF%E7%94%A8yarn%E4%B8%8B%E8%BD%BD%E5%85%A8%E5%B1%80%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/" title="使用yarn下载全局包的一些坑">使用yarn下载全局包的一些坑</a>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#使用yarn全局安装Vue Cli</span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure>

<p>ℹ️&emsp;注：如果使用<code>yarn global add vue-cli</code>则安装的是<strong>Vue Cli 2.x的版本</strong></p>
<p>安装的是最新版，但是由于最新版本与Vue Cli2的<strong>初始化项目方式不同</strong>，如果有需要我们可以拉去2.x模板。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">yarn global add @vue/cli-init</span><br><span class="line"># `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用Vue Cli2初始化项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init webpack [项目名称]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Vue Cli3+初始化项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue creat [项目名称]</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="Vue-Cli2的使用"><a href="#Vue-Cli2的使用" class="headerlink" title="Vue Cli2的使用"></a>Vue Cli2的使用</h1>]]></content>
      <categories>
        <category>Web前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的使用</title>
    <url>/2020/09/23/webpack%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="webpack中的loader"><a href="#webpack中的loader" class="headerlink" title="webpack中的loader"></a>webpack中的<strong>loader</strong></h1><h2 id="loader的作用"><a href="#loader的作用" class="headerlink" title="loader的作用"></a>loader的作用</h2><ol>
<li><p>在之前的案例中，主要是使用webpack来处理所写的JS代码，并通过webpack来自动处理他们之间的依赖。</p>
</li>
<li><p>但是在实际开发中并不只JS文件的处理，还会加载css文件、图片等，对于webpack本身来说，对于这些转化是不支持的。</p>
</li>
<li><p>所以就需要给webpack扩展对应的loader。</p>
<a id="more"></a>

</li>
</ol>
<h2 id="loader的使用"><a href="#loader的使用" class="headerlink" title="loader的使用"></a>loader的使用</h2><ol>
<li>通过npm安装所需要的loader。(<a href="https://www.webpackjs.com/">webpack中文官网</a>)</li>
<li>webpack.config.js中的modules属性下配置。</li>
</ol>
<h2 id="webpack的loader"><a href="#webpack的loader" class="headerlink" title="webpack的loader"></a>webpack的loader</h2><h3 id="css-loader-和-style-loader"><a href="#css-loader-和-style-loader" class="headerlink" title="css-loader 和 style-loader"></a>css-loader 和 style-loader</h3><p>当没有使用css-loader时，直接在main.js文件中引用依赖然后打包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//normal.css</span></span><br><span class="line">body &#123;</span><br><span class="line">	background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;name,age,say,run&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./js/info.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(say);</span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="comment">//依赖CSS文件，使得webpack打包时会处理normal.css文件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./css/normal.css&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>控制台会输出如下错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/serystal/heyuhangspic/20200922165432.png" alt="合适的loader处理"></p>
<p>所以需要安装css-loader来处理css文件。使用<code>npm install --save-dev css-loader</code>。<br>💥<font color="red"><code>--save-dev</code> 为开发时依赖模块，意为只用于开发，实际项目运行时并不依赖。</font> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line"> &#123;</span><br><span class="line">   test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">   use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注： 如果只是安装css-loader并打包，在DOM中并不会显示出css文件定义的效果。因为css-loader只是<strong>将css文件加载</strong>，想要将加载好的css文件渲染到DOM中，还需要安装<strong>style-loader</strong>(<code>npm install style-loader --save-dev</code>)；</p>
<p> 在使用<code> use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]</code>这个语句时，应注意在使用多个loader时，loader的执行顺序是从右往左，所以应该将style-loader放在左边，先执行css-loader加载css文件之后，再由style-loader渲染到DOM中。</p>
</blockquote>
<h3 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h3><blockquote>
<p>Less 是一门 <strong>CSS 预处理语言</strong>，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。</p>
</blockquote>
<p><strong>less-loader</strong>用于处理JS文件中对less文件的依赖。</p>
<ol>
<li><p>安装less-loader：使用指令<code>npm install --save-dev less-loader less</code>。</p>
<p>*⚠️注： 如需安装指定版本，需要在loader后加 <code>@+版本号</code>*。以下同理。</p>
</li>
<li><p>在webpack.config.js文件中配置(执行顺序是<strong>自下而上</strong>)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> test: <span class="regexp">/\.less$/</span>,</span><br><span class="line"> use: [&#123;</span><br><span class="line">  loader: <span class="string">&quot;style-loader&quot;</span></span><br><span class="line"> &#125;, &#123;</span><br><span class="line">     loader: <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      	loader: <span class="string">&quot;less-loader&quot;</span>, <span class="attr">options</span>: &#123;</span><br><span class="line">      	strictMath: <span class="literal">true</span>,</span><br><span class="line">      	noIeCompat: <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line"> &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>使用<code>url-loader</code>加载css样式中的一些图片等文件。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>使用指令：<code>npm install --save-dev url-loader</code>。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在<strong>webpack.config.js</strong>中配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line"> use: [&#123;</span><br><span class="line">  loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">   <span class="comment">//当文件小于limit所定义的数值时，会将图片编译成base64字符串形式。</span></span><br><span class="line">   <span class="comment">//当图片大于limit定义的数值时，打包会报错，就需要使用file-loader模块进行加载。</span></span><br><span class="line">   limit: <span class="number">13000</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 🔊如果插入的图片过大，就需要使用 file-loader模块进行加载。</p>
<h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><blockquote>
<p>用于处理<strong>大文件</strong>的加载.</p>
</blockquote>
<ol>
<li><p>安装指令: <code>npm install --save-dev file-loader</code>。</p>
</li>
<li><p>然后再次运行打包指令。</p>
</li>
<li><p>运行index.html，控制台会提示找不到文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200923202519.png"></p>
</li>
<li><p>是由于使用webpack打包时，webpack会把图片文件放到打包文件同一路径下直接引用，但是是直接引用，未指定前置路径。</p>
<p>​                                            <img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/123.jpg"></p>
<center><font size="2">同一路径</font></center>                                

<p><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200923203232.png"></p>
<center><font size="2">没有前置路径</font></center>    
</li>
<li><p>在调试中将url路径改为<br><code>url(dist/8e08b79ef4c5e855db743e16c3b5f2a1.png)</code>，<br>此时页面就会正常渲染。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200923203926.png"></p>
</li>
<li><p>如果想要解决这个问题，就需要使background后的url引用路径改为<code>dist/xxx.jpg</code>。在webpack.config.js文件中加入<code>publicPath: &#39;dist/&#39;</code>。意为只要涉及到url的问题，都会自动地在文件前面加上==dist/==。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200923204400.png"></p>
<center><font size="2">问题解决</font></center>

<table><tr><td bgcolor=PowderBlue>💡当index.html文件也在<b>dist</b>文件夹下，<br />则不需要再使用 <i>publicPath: 'dist/'</i>指令</td></tr></table>

<h4 id="关于生成的文件名"><a href="#关于生成的文件名" class="headerlink" title="关于生成的文件名"></a>关于生成的文件名</h4><ul>
<li><p>webpack会在打包时将文件放入打包文件的同一目录下，并且会生成一个32位的hash值，防止文件命名重复。</p>
</li>
<li><p>但是在实际的开发中，我们可能对打包的名字有一定的要求——比如，将所有的图片放在一个文件夹中，但是需要跟上原来的名字，同时还要防止重复。</p>
</li>
<li><p>此时我们需要在options中添加一个<strong>name</strong>属性：</p>
<ul>
<li><code>img</code>：文件要打包的文件夹；</li>
<li><code>name</code>：获取图片原来的名字，放在该位置；</li>
<li><code>hash:8</code>：为了防止图片名称重复，依然使用hash，但是只保留8位；</li>
<li><code>ext</code>：原来的图片扩展名。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用[name]就是使用图片原有的name，使用.是将名称连接起来</span></span><br><span class="line">name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将原本打包好的的文件删除，然后重新打包<code>npm run build</code>。</p>
<p>​                                                    <img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/Snipaste20200923222351.jpg"></p>
</li>
</ul>
<center><font size="2">完成打包在img目录下的自定义图片名称</font></center>



<h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p><font color="green">🏆我们上述的打包文件中会有ES6的语法，当浏览器不支持ES6时会无法正常渲染，所以我们需要使用babel-loader模块完成转换。</font></p>
<ul>
<li><p>安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install babel-loader babel-core babel-preset-env webpack</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">	<span class="comment">//由于最后打包完成并运行node依赖文件并不参加，所以使用exclude将文件排除</span></span><br><span class="line"> exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line"> use: &#123;</span><br><span class="line"> 	loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line"> 	options: &#123;</span><br><span class="line">	 <span class="comment">// presets: [&#x27;@babel/preset-env&#x27;]</span></span><br><span class="line">		<span class="comment">// 为什么使用2015版本不知</span></span><br><span class="line">		presets: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>再次运行<code>npm run build</code>。打包完成，然后进入打包好的文件<strong>bundle.js</strong>搜索ES6的语法(如<code>let</code>,<code>const</code>)，没有搜到，说明已经成功将ES6的语法转化为ES5。<br><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200924181951.png" alt="没有const"><br><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200924182035.png" alt="没有let"></li>
</ul>
</li>
</ul>
<h1 id="webpack配置Vue"><a href="#webpack配置Vue" class="headerlink" title="webpack配置Vue"></a>webpack<strong>配置Vue</strong></h1><h2 id="Vue模块"><a href="#Vue模块" class="headerlink" title="Vue模块"></a>Vue模块</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>在之前的学习过程中，在项目中引用Vue大致是使用两种方法：</p>
<ol>
<li><p>下载Vue.js文件，然后通过<code>&lt;script&gt;</code>标签引入；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用cdn引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>💥而这两种方法都是不符合我们的<strong>模块化</strong>开发思想的，模块化开发应该是以引入模块的方式进行使用。所以我们需要使用npm安装的方式来引入vue模块。</p>
<p>使用指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>

<p><font color="green">注：由于Vue在运行时也是需要依赖的，所以不需要使用<code>--save-dev。</code></font></p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>在js文件中使用vue进行开发：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用vue进行开发</span></span><br><span class="line"><span class="comment">//导入vue模块，引号中的vue就是安装好的vue模块</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&#x27;hello webpack&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在index.html文件中输入代码并执行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="运行时的错误-模板编译器"><a href="#运行时的错误-模板编译器" class="headerlink" title="运行时的错误-模板编译器"></a>运行时的错误-模板编译器</h3><ol>
<li><p>并没有执行，浏览器会抛出一个错误：<br><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/image-20200924224202310.png" alt="正在使用vue的runtime-only版本，模板编译器不可用。"></p>
<p>🗨️这是由于vue模块有两个版本：<code>runtime-only</code> 和 <code>runtime-compiler</code>：</p>
<ul>
<li>runtime-only =&gt; 代码中不可以有任何的<strong>template</strong>；</li>
<li>runtime-compiler  =&gt; 代码可以有<strong>template</strong>，因为有<code>compiler</code>用于编译template。</li>
</ul>
<p>🗨️因为使用的是前者打包，它其中并没有包含模板编译器，所以浏览器无法正常运行。<font size=2 color=red>被Vue实例el属性挂载的元素也可以看做是一个模板</font></p>
</li>
<li><p>解决这个问题需要在webpack.config.js文件中加入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  <span class="comment">//别名</span></span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="comment">// vue$表示以vue结尾的文件,由于默认情况下vue使用的是vue.runtime.js，所以我们需要将vue的默认使用改变从而使用runtime-compiler。</span></span><br><span class="line">    <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center><font size=2>是将Vue的默认使用文件改变为<b>vue.esm.js</b>从而可以使用模板编译器</font></center>
</li>
<li><p>再次<code>npm run build</code>，就可以在浏览器中正常渲染啦！<br><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/1154545454545454.jpg" alt="hello webpack"></p>
</li>
</ol>
<h2 id="创建Vue时el和template的关系"><a href="#创建Vue时el和template的关系" class="headerlink" title="创建Vue时el和template的关系"></a>创建Vue时el和template的关系</h2><blockquote>
<p>在上面的代码可以正常运行后，有一个问题出现了：</p>
<p>❓ 当我们后续想要添加或修改data或其他属性的引用方式，我们就需要在index.html中修改相应的代码。那么有没有一种方法可以使我们在js文件中就可以修改呢？</p>
</blockquote>
<h3 id="Vue实例中的template属性"><a href="#Vue实例中的template属性" class="headerlink" title="Vue实例中的template属性"></a>Vue实例中的template属性</h3><p>答案是我们可以在Vue实例中定义一个<strong>template</strong>属性：</p>
<ul>
<li><p>在之前，我们只是定义了el属性，使得Vue实例对html中一个元素进行绑定；</p>
</li>
<li><p>现在我们只在html中保留一个div#app的元素，然后在Vue实例中定义一个<code>template</code>属性；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;btnClick&quot;&gt;点击事件&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&#x27;hello webpack&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;coderbut&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    btnClick()&#123;</span><br><span class="line">      alert(<span class="string">&#x27;alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成之后即使html页面只有一个div#app元素，也可以正常渲染。有利于文件的分离。<br><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/image-20200925003902466.png" alt="正常渲染"></p>
</li>
</ul>
<h3 id="分离写法"><a href="#分离写法" class="headerlink" title="分离写法"></a>分离写法</h3><p>在上面，使用了Vue实例中的template属性，从而使前端html文件中只有一个div#app的元素。</p>
<p>我们可以定义一个子组件，将属性从Vue实例中分离出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;btnClick&quot;&gt;点击事件&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&#x27;hello webpack&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;coderbut&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    btnClick() &#123;</span><br><span class="line">      alert(<span class="string">&#x27;alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在Vue实例中注册模板，并在实例中的<code> template</code>属性中使用组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App /&gt;&#x27;</span>,</span><br><span class="line">  components:&#123;</span><br><span class="line">    App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打包并运行，这样也可以得到相同的效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/blogimg/whatever/20200925142500.png" alt="template: ‘&lt;App /&gt;’"></p>
<h3 id="模块化-在js文件中导出"><a href="#模块化-在js文件中导出" class="headerlink" title="模块化 - 在js文件中导出"></a>模块化 - 在js文件中导出</h3><p>✨除了上述在一个js文件中定义一个子组件，还可以在另一个js文件中定义并导出，然后在mian.js文件中导入。</p>
<ol>
<li><p>定义一个App.js文件，并编辑。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//App.js</span></span><br><span class="line"><span class="comment">//default表示导出一个模块并且由导入者命名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;btnClick&quot;&gt;点击事件&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&#x27;hello webpack&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;coderbut&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    btnClick() &#123;</span><br><span class="line">      alert(<span class="string">&#x27;alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./js/App&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App /&gt;&#x27;</span>,</span><br><span class="line">  components:&#123;</span><br><span class="line">    App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包并运行，依然可以得到相同的效果。</p>
</li>
</ol>
<h3 id="模块化-在-vue文件中配置"><a href="#模块化-在-vue文件中配置" class="headerlink" title="模块化 - 在.vue文件中配置"></a>模块化 - 在<code>.vue</code>文件中配置</h3><p>在使用vue模块中，我们可以定义后缀为<code>.vue</code>的文件，在里面定义属性模板，之后在js文件中引用。</p>
<ol>
<li><p>首先创建一个App.vue文件。<br><img src="https://cdn.jsdelivr.net/gh/serystal/heyuhangspic/img/Snipaste20200925154258521.jpg" alt="vue文件模板"></p>
</li>
<li><p>在vue文件中编辑。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      msg: <span class="string">&#x27;hello webpack&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;coderbut&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    btnClick() &#123;</span><br><span class="line"><span class="javascript">      alert(<span class="string">&#x27;alert&#x27;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--可以为模板内的元素定义样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">h2 &#123;</span><br><span class="line">  color: powderblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.js文件中导入该文件，注意此时文件需要加后缀；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./vue/App.vue&#x27;</span>;</span><br><span class="line">mport App <span class="keyword">from</span> <span class="string">&#x27;./vue/App.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App /&gt;&#x27;</span>,</span><br><span class="line">  components:&#123;</span><br><span class="line">    App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>💡&emsp;如果不想导入的时候加后缀，可以在webpack.config.js文件中配置<code>resolve</code>属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">      <span class="comment">//该属性表示可以省略的后缀名</span></span><br><span class="line">  extensions:[<span class="string">&#x27;.js&#x27;</span>,<span class="string">&#x27;.css&#x27;</span>,<span class="string">&#x27;.vue&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>此时如果直接打包会报错；<br><img src="https://cdn.jsdelivr.net/gh/serystal/heyuhangspic/img/Snipaste20200925161252619.png" alt="需要使用vue-loader"></p>
</li>
<li><p>我们需要安装<strong>vue-loader</strong>和<strong>vue-template-compiler</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure>

<p>然后在webpack.config.js文件中添加规则:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//意为 .vue 文件使用vue-loader处理</span></span><br><span class="line">    test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">    use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>🚨注：在vue-loader<strong>14版本</strong>之后，使用vue-loader需要另外配置一个插件，这次我们把vue-loader的版本改到13 。</p>
</li>
<li><p>更改vue-loader版本。</p>
<p>进入package.json文件，将vue-loader的版本改为<code>^13.0.0</code> 。再次运行<code>npm install</code>。</p>
</li>
<li><p>安装完成之后再次运行<code>npm run build</code>进行打包。</p>
</li>
<li><p>运行。<br><img src="https://cdn.jsdelivr.net/gh/serystal/heyuhangspic/img/Snipaste20200925163357818.png" alt="可以正常运行，并且定义 样式也生效了"></p>
</li>
</ol>
<p>当然，在vue文件中也可以导入vue文件(套娃警告)。</p>
<ol>
<li><p>定义另一个vue文件<code>Cpn.vue</code>；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cpn.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;Cpn&quot;</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&#x27;cpn template&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在App.vue中导入并注册；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">    Cpn</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后重新打包并运行，就可以看到我们在App.vue中使用的Cpn.vue的内容了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200925213653022.png" alt="执行效果"></p>
</li>
</ol>
<h1 id="webpack的plugin-插件"><a href="#webpack的plugin-插件" class="headerlink" title="webpack的plugin(插件)"></a>webpack的<strong>plugin(插件)</strong></h1><h2 id="什么是plugin？"><a href="#什么是plugin？" class="headerlink" title="什么是plugin？"></a>什么是plugin？</h2><p>🦆    plugin是插件的意思，通常是用于对某个现有的架构进行扩展；</p>
<p>🦆    webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</p>
<h2 id="plugin和loader的区别"><a href="#plugin和loader的区别" class="headerlink" title="plugin和loader的区别"></a>plugin和loader的区别</h2><p>👁️    loader主要用于转换某些类型的模块，它是一个<strong>转换器</strong>；</p>
<p>👁️    plugin是插件，它是对webpack本身的扩展，是一个<strong>扩展器</strong>。</p>
<h2 id="plugin的使用"><a href="#plugin的使用" class="headerlink" title="plugin的使用"></a>plugin的使用</h2><ol>
<li>通过npm安装需要使用plugins(某些webpack内置的插件无需安装)；</li>
<li>在webpack.config.js文件中<code>plugins</code>中配置插件。</li>
</ol>
<h2 id="webpack的各种plugins"><a href="#webpack的各种plugins" class="headerlink" title="webpack的各种plugins"></a>webpack的各种plugins</h2><h3 id="BannerPlugin插件"><a href="#BannerPlugin插件" class="headerlink" title="BannerPlugin插件"></a>BannerPlugin插件</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>BannerPlugin是webpack的<strong>自带插件</strong>，用来为打包的文件添加版本声明。</p>
<h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><ol>
<li><p>修改webpack.config.js文件(由于是自带插件，所以不需要安装)：</p>
<ul>
<li><p>首先导入webpack模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入webpack</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在属性中添加<code>plugins</code>属性并定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">	<span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;最终版权归coderbut所有&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>重新打包，然后在打包好的bundle.js文件中就可以看到我们用BannerPlugin定义的内容了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200926004815291.png" alt="BannerPlugin"></p>
</li>
</ol>
<h3 id="HtmlWebpackPlugin插件"><a href="#HtmlWebpackPlugin插件" class="headerlink" title="HtmlWebpackPlugin插件"></a>HtmlWebpackPlugin插件</h3><p>目前我们的index.html是存放于<strong>根目录</strong>下的，在发布项目时，只是会发布<code>dist</code>文件夹，但是如果该文件夹下没有index.html文件，那么打包好的js文件也就无法使用了，所以我们需要将index.html文件也打包到dist文件夹中，这时就需要使用<code>HtmlWerbpackPlugin</code>插件了。</p>
<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>▶️&emsp;自动生成一个index.html文件(可以指定模板生成)；</p>
<p>▶️&emsp;将打包好的js文件，通过<code>&lt;script&gt;</code>标签插入到<code>&lt;body&gt;</code>中。</p>
<h4 id="具体使用-1"><a href="#具体使用-1" class="headerlink" title="具体使用"></a>具体使用</h4><ol>
<li><p>安装插件(学习的时候安装3.2.0版本，高版本会报错)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin@3.2.0 --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改webpack.config.js中的<code>plugins</code>内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">	<span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包，之后就可以在dist目录下看到index.html文件，并且自动引入了bundle.js文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200926013829932.png" alt="dist文件下的index.html"></p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200926013926906.png" alt="自动引入了bundle.js"></p>
<p>注： 由于现在index和bundle文件打包在同一目录下,所以我们不再需要使用webpack.config.js文件中的<code>publicPath</code>属性来指定路径。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste202009260151467761223.png" alt="注释掉publicPate"></p>
</li>
</ol>
<h3 id="UglifyjsWebpackPlugin插件"><a href="#UglifyjsWebpackPlugin插件" class="headerlink" title="UglifyjsWebpackPlugin插件"></a>UglifyjsWebpackPlugin插件</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>压缩打包好的js文件。使js文件变得可读性差。</p>
<h4 id="具体使用-2"><a href="#具体使用-2" class="headerlink" title="具体使用"></a>具体使用</h4><ol>
<li><p>安装插件(安装1.1.0版本，跟着老师做，先用指定版本~不然报错没法整，也是与cli的版本对应)；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin@1.1.0 --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>在webpack.config.js中配置；</p>
<ul>
<li><p>引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入UglifyWebpackPlugin插件</span></span><br><span class="line"><span class="keyword">const</span> UglifyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置plugins</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> UglifyWebpackPlugin()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>再次打包，找到bundle.js文件查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200926150047481.png" alt="压缩混淆之后"></p>
</li>
</ol>
<h1 id="webpack-dev-server搭建本地服务器"><a href="#webpack-dev-server搭建本地服务器" class="headerlink" title="webpack-dev-server搭建本地服务器"></a>webpack-dev-server搭建本地服务器</h1><h2 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h2><p>webpack提供了一个可选的基于nodejs的本地开发服务器，内部使用express框架，可以使浏览器自动刷新显示我们修改之后的结果。</p>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>使用npm安装该模块(跟着老师做，先用指定版本~不然报错没法整，也是与cli的版本对应)；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server@2.9.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>在熟悉的webpack.config.js文件中配置<code>devserver</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="comment">//为哪个文件夹提供本地服务，默认根文件夹</span></span><br><span class="line">  contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">  <span class="comment">//是否实时监听</span></span><br><span class="line">  inline: <span class="literal">true</span></span><br><span class="line">  <span class="comment">//端口号,先不配置了</span></span><br><span class="line">  <span class="comment">//port: </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再去package.json中配置一个<code>scripts</code>；</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --open&quot;   // --open是打开浏览器</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后再运行<code>npm run dev</code>，会启动监听并打开浏览器，此时的路径就为</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200926210723913.png" alt="localhost:8080"></p>
</li>
<li><p>实时监听效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/GIF20209262212159.gif" alt="实时改变样式"></p>
</li>
</ol>
<h1 id="webpack配置文件分离"><a href="#webpack配置文件分离" class="headerlink" title="webpack配置文件分离"></a>webpack配置文件分离</h1><h2 id="为什么这样做"><a href="#为什么这样做" class="headerlink" title="为什么这样做"></a>为什么这样做</h2><p>在webpack.config.js文件中，我们有的配置是需要在开发时配置的，而实际运行时并不需要，比如WebpackDevServer模块、各种plugin。</p>
<h2 id="具体使用-3"><a href="#具体使用-3" class="headerlink" title="具体使用"></a>具体使用</h2><ol>
<li><p>分离我们的配置文件，定义三个配置文件。</p>
<ul>
<li><strong>base.config.js</strong>：用于存储开发和运行公用的配置，即这里面的配置既是开发时依赖，也是运行时依赖；</li>
<li><strong>dev.config.js</strong>：开发时特殊的配置放在dev配置文件里面，只是开发时需要，实际运行时不需要的配置；</li>
<li><strong>prod.config.js</strong>：生产时(运行时)特殊的配置放在prod配置文件里面。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//base.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;最终版权归coderbut所有&#x27;</span>),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dev.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    inline: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//prod.config.js</span></span><br><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> UglifyjsWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<code>webpack-merge</code>模块(还是低版本，教程比较老，为了学习~)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-merge@4.1.5 --save-dev</span><br></pre></td></tr></table></figure>

<p>之后在各个文件中导入并使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//prod.config.js</span></span><br><span class="line"><span class="comment">//导入WebpackMerge和base.config.js</span></span><br><span class="line"><span class="keyword">const</span> WebpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> BaseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="comment">//使用WebpackMerge</span></span><br><span class="line"><span class="comment">//意为将第二个参数里的数据和导入的base.config.js文件合并</span></span><br><span class="line"><span class="built_in">module</span>.exports = WebpackMerge(BaseConfig,&#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> UglifyjsWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WebpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> BaseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WebpackMerge(BaseConfig,&#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    inline: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除webpack.config.js文件，之后运行打包程序，终端会报错；</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200926235829401.png" alt="没有找到配置文件"></p>
</li>
<li><p>此时我们需要在package.json中的<code>script</code>属性中配置，为其中的自定义指令指令添加额外的命令；</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义配置文件</span></span><br><span class="line">   &quot;build&quot;: &quot;webpack --config ./build/prod.config.js&quot;,</span><br><span class="line">   &quot;dev&quot;: &quot;webpack-dev-server --open --config ./build/dev.config.js&quot;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>再次打包，就可以成功了。</p>
</li>
<li><p>但是仍然会存在一个问题，就是在打包成功之后，打包好的bundle.js文件会在build文件下新建的dist文件夹中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/coderbut/heyuhangspic/img/Snipaste20200927001505345.png" alt="路径问题"></p>
<p>解决这个问题只需要进入base.config.js文件，找到当时定义的<code>path</code>属性，然后修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line"> output: &#123;</span><br><span class="line">   <span class="comment">//找到上一层然后拼接dist</span></span><br><span class="line">   path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">   filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>修改完成之后再次打包，打包好的文件就会出现在该出现的位置了(根目录下的dist文件夹)。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
